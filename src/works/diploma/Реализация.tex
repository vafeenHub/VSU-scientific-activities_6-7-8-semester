\section*{4. Реализация}
\addcontentsline{toc}{section}{4. Реализация} % Добавляем в оглавление

Этапы реализации могут быть представлены в виде схемы (рис.~\ref{fig:fig1}).

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1.0\textwidth]{1.png}
	\caption{Схема этапов реализации приложения}
	\label{fig:fig1}
\end{figure}

\subsection*{4.1. Подключение зависимостей}
\addcontentsline{toc}{subsection}{4.1. Подключение зависимостей} % Добавляем в оглавление

Для написания приложения нужно добавить необходимые библиотеки в Gradle файле на уровне приложения: 
\begin{enumerate}
	\item Retrofit – это библиотека для работы с HTTP-запросами в Android-приложениях. Она используется для взаимодействия с собственным API, обеспечивая удобный и эффективный способ отправки запросов и обработки ответов. Конвертер Gson позволяет автоматически преобразовывать JSON-ответы от API в объекты Kotlin, что упрощает работу с данными.   \cite{ref7}\cite{ref8}
	
	\item Glide – это библиотека для загрузки и отображения изображений. Она используется для отображения картинок котиков на интерфейсе, а также их кэширования для повышения производительности. \cite{ref7}
	
	\item AndroidX Libraries предоставляет современные компоненты и инструменты для разработки Android-приложений, улучшая совместимость и функциональность. \cite{ref7}
	
	\item Jetpack Compose для декларативной верстки экранов приложения. \cite{ref7}
	
	\item Jetpack Navigation: обеспечивает удобный способ навигации между экранами приложения, упрощая управление компонентами и навигационными действиями. 
	
	\item Koin – это библиотека для внедрения зависимостей, которая упрощает создание и управление зависимостями в приложении, улучшая модульность и тестируемость кода.
	
	\item Room – это библиотека для работы с базой данных SQLite, предоставляющая удобный и безопасный способ хранения и управления данными в приложении. Благодаря ей будет происходить хранение информации о треках, плейлистах и избранном.
\end{enumerate}

\subsection*{4.2. Верстка экранов}
\addcontentsline{toc}{subsection}{4.2. Верстка экранов} % Добавляем в оглавление

Все экраны приложения верстаются с помощью Kotlin Declarative подхода Jetpack Compose. На этом этапе вынесены отдельно строковые и цветовые ресурсы, необходимые шрифты и векторные изображения для иконок. Для всех частей интерфейса используются стандартные UI-элементы Android SDK.[2]
Приложение состоит из двух основных экранов: расписание и настройки. Смена состояния основного Activity с Bottom Bar осуществляется при помощи помещения одного из двух фрагментов в Scaffold. Расписание занятий отображается с помощью Column, где каждый элемент списка – это контейнер для события, куда записывается информация о занятии. Пока не начата работа с сетью, оставлены изображения-заглушки и тестовый текст, чтобы убедиться в корректности отображения интерфейса. \cite{ref8}
Для похожих элементов UI необходимо вынести одинаковые атрибуты в отдельный стиль для дальнейшего повторного использования. Также необходимо добавить поддержку светлой и темной темы, чтобы пользователи могли выбирать наиболее удобный для себя вариант отображения интерфейса. Ниже на рис. ~\ref{fig:main_screen} и рис. ~\ref{fig:settings_screen} изображена итоговая верстка экранов с тестовыми данными.


\subsection*{4.3. Реализация навигации}
\addcontentsline{toc}{subsection}{4.3. Реализация навигации} % Добавляем в оглавление
На данном этапе необходимо связать сверстанные экраны в единое приложение. Для реализации логики Bottom Bar будет использоваться Jetpack Navigation. При нажатии на элементы расписания необходимо обеспечить переход на соответствующие детальные экраны или выполнить другие действия, такие как открытие дополнительной информации о занятии. \cite{ref8}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{13.png}
        \caption{Макет главного экрана}
        \label{fig:main_screen}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{14.png}
        \caption{Макет экрана настроек}
        \label{fig:settings_screen}
    \end{minipage}
\end{figure}

На экране настроек при нажатии кнопки «Назад» необходимо вернуться на предыдущий экран. Это реализовано с помощью стандартных механизмов навигации в Android, например, NavController. \cite{ref8}
До реализации взаимодействия с базой данных полная функциональность некоторых экранов будет ограничена. Однако, основная логика навигации и переходов между экранами будет реализована для обеспечения плавного пользовательского опыта.

\subsection*{4.4. Проверка HTTP-запросов}
\addcontentsline{toc}{subsection}{4.4. Проверка HTTP-запросов} % Добавляем в оглавление

Ниже, на рис. ~\ref{fig:fig2}, рис. ~\ref{fig:fig3}, рис. ~\ref{fig:fig4}, рис. ~\ref{fig:fig5}, изображены тестовые обращения для проверки запросов к собственному API через Postman. Все данные, необходимые для отображения пользователю, существуют и корректны.  \cite{ref9}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{2.png}
	\caption{Запрос получения преподавателей}
	\label{fig:fig2}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{3.png}
	\caption{Запрос получения групп}
	\label{fig:fig3}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{4.png}
	\caption{Запрос получения расписания конкретной группы}
	\label{fig:fig4}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{5.png}
	\caption{Запрос получения расписания конкретного преподавателя}
	\label{fig:fig5}
\end{figure} 

\subsection*{4.5. Модели данных}
\addcontentsline{toc}{subsection}{4.5. Модели данных} % Добавляем в оглавление

Следующие модели данных, изображенные на рис. ~\ref{fig:fig6}, используются для конвертации в них HTTP-ответов от сервера в формат JSON и обработки для дальнейшего помещения в базу данных и отображения на интерфейсе. 
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{6.png}
	\caption{Диаграмма классов для моделей данных сетевых репозиториев}
	\label{fig:fig6}
\end{figure} 
\begin{enumerate}
	\item LessonDto: модель для представления информации о занятии.
 	\item TeacherDto: модель для представления информации о преподавателе.
	\item GroupDto: модель для представления информации о группе студентов.
\end{enumerate}

\subsection*{4.6. Логика работы с сетью}
\addcontentsline{toc}{subsection}{4.6. Логика работы с сетью} % Добавляем в оглавление

Основная цель работы с сетью — обеспечение взаимодействия приложения с API, для получения информации о расписании по запросу пользователя. \cite{ref6}

Для работы с сетью в приложении используются следующие ключевые компоненты, диаграмма которых изображена на рис. \ref{fig:fig7}: 



\begin{enumerate}
    \item Интерфейсы LessonRemoteRepository, GroupRemoteRepository, Teacher-RemoteRepository. Определяют методы, которые принимает объект запроса и возвращает объект ответа. Эти интерфейсы позволяет абстрагироваться от конкретных деталей реализации сетевого взаимодействия, обеспечивая гибкость и возможность замены реализации при необходимости.
	
    \item Классы LessonRemoteRepositoryImpl, GroupRemoteRepositoryImpl, TeacherRemoteRepositoryImpl. Реализуют интерфейсы Lesson-RemoteRepository, GroupRemoteRepository, TeacherRemoteRepository и используют библиотеку Retrofit для выполнения сетевых запросов. Здесь проверяется сетевое подключение – прежде чем отправить запрос, проверяется наличие активного интернет-соединения. Если соединение отсутствует, возвращается ответ с соответствующим кодом ошибки. А также обрабатывается сам запрос: методы принимают параметры запроса и выполняют сетевой запрос к API. В случае успешного выполнения запроса возвращается ответ с кодом 200 и полученными данными. В случае ошибки (например, при отсутствии соединения или неверном типе запроса) возвращаются соответствующие коды ошибок.\cite{ref9}
\end{enumerate}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{7.png}
	\caption{Диаграмма классов для сетевых репозиториев}
	\label{fig:fig7}
\end{figure}

\subsection*{4.7. Логика работы с базой данных}
\addcontentsline{toc}{subsection}{4.7. Логика работы с базой данных} % Добавляем в оглавление

Для обеспечения надежного и эффективного хранения данных о занятиях в приложении используется библиотека Room, которая предоставляет удобный интерфейс для работы с SQLite базой данных в Android-приложениях. Для реализации функциональности работы с базой данных в приложении используются следующие основные компоненты:
\begin{enumerate}
	\item Entity-классы представляют собой модели данных, которые будут сохраняться в базе данных. В приложении используются следующие Entity-классы, которые изображены ниже на рис. ~\ref{fig:fig8}:
		\begin{itemize}
		\item LessonEntity: представляет информацию о занятии, включая его идентификатор, название, время начала и конца, аудиторию, преподавателя и т. д.
		\item TeacherEntity: представляет информацию о преподавателе, включая его идентификатор, имя, должность и т. д.
		\item GroupEntity: представляет информацию о группе студентов, включая ее идентификатор, название и т. д.
		\item ReminderEntity: представляет информацию о напоминании о занятии
		\end{itemize}
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.8\textwidth]{8.png}
			\caption{Схема базы данных}
			\label{fig:fig8}
		\end{figure} 
		
	\item DAO (Data Access Object) интерфейсы определяют методы для взаимодействия с базой данных. В нашем приложении используются три DAO-интерфейса, которые изображены на рис ~\ref{fig:fig9}:
		\begin{itemize}
		\item LessonDao: определяет методы для вставки, удаления и получения занятий из базы данных.
		\item TeacherDao: определяет методы для вставки, удаления и получения преподавателей из базы данных.
		\item GroupDao: определяет методы для вставки, удаления и получения групп из базы данных.
		\end{itemize}
\end{enumerate}



Эти интерфейсы аннотированы с использованием аннотаций Room, таких как \texttt{@Insert}, \texttt{@Delete} и \texttt{@Query}, которые определяют SQL-запросы, выполняемые для соответствующих операций. \cite{ref10}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{9.png}
	\caption{Диаграмма классов базы данных}
	\label{fig:fig9}
\end{figure} 


\begin{enumerate}[start=3]
    \item Абстрактный класс базы данных наследуется от \texttt{RoomDatabase} и представляет собой точку входа для взаимодействия с базой данных. В нашем приложении определены следующие классы:
    
    \begin{itemize}
        \item AppDatabase: абстрактный класс для работы с таблицей занятий. Содержит абстрактные свойства \texttt{lessonDao}, \texttt{groupDao}, \texttt{teacherDao}, возвращающие экземпляры интерфейсов \texttt{LessonDao}, \texttt{GroupDao} и \texttt{TeacherDao} соответственно.
    \end{itemize}

    \item Клиент базы данных предоставляет методы для взаимодействия с базой данных через DAO-интерфейсы. В нашем приложении используется класс \texttt{AppDatabase\_Impl}, который реализует интерфейс \texttt{AppDatabase}. Этот класс определяет методы для сохранения, удаления и получения занятий. Класс \texttt{AppDatabase\_Impl} инкапсулирует логику работы с базой данных, обеспечивая удобный интерфейс для других компонентов приложения. Он использует инъекцию зависимости для получения экземпляра базы данных и обеспечивает выполнение CRUD-операций через соответствующие DAO-интерфейсы.
\end{enumerate}


\subsection*{4.8. Архитектура приложения}
\addcontentsline{toc}{subsection}{4.8. Архитектура приложения} % Добавляем в оглавление

Приложение будет разработано с соблюдением принципов SOLID и чистой архитектуры. Применение этих принципов обеспечивает высокую степень модульности, гибкости и тестируемости кода, а также упрощает поддержку и расширение функциональности. \cite{ref3}

Чистая архитектура разделяет систему на несколько слоев, каждый из которых имеет чётко определённые задачи и зависимости. Это позволяет легко изменять и масштабировать приложение, а также улучшает его тестируемость. В соответствии с чистой архитектурой в приложении выделены следующие основные слои:

\begin{enumerate}
    \item \textbf{Внешний слой (UI Layer)}: включает все компоненты, связанные с пользовательским интерфейсом, такие как фрагменты и активности. Основная задача UI Layer - отображение данных и взаимодействие с пользователем. Этот слой получает данные из ViewModel и обновляет интерфейс в соответствии с изменениями в данных~\cite{ref3}.
    \item \textbf{Слой данных (Data Layer)}: содержит компоненты, связанные с управлением данными, включая DAO-интерфейсы для работы с Room, реализации сетевых запросов с использованием Retrofit, а также клиентов базы данных и сетевых клиентов. Data Layer отвечает за получение и хранение данных, предоставляя их в Domain Layer через репозитории~\cite{ref3}.
    \item \textbf{Слой домена (Domain Layer)}: содержит бизнес-логику и бизнес-модели. Domain Layer не зависит от других слоев и содержит основные бизнес-правила и интерфейсы репозиториев~\cite{ref3}.
    \item \textbf{Слой приложений (Application Layer)}: содержит ViewModel, которые объединяют бизнес-логику с логикой представления и управления состоянием. ViewModel взаимодействуют с репозиториями для получения данных и обработки пользовательских действий.
\end{enumerate}

Для разделения представления и логики управления данными в приложении используется паттерн MVVM (Model-View-ViewModel). Этот паттерн обеспечивает чёткое разделение обязанностей между компонентами приложения:

\begin{enumerate}
    \item \textbf{Model}: включает бизнес-логику и данные приложения. Модель получает данные из Data Layer и предоставляет их ViewModel.
    \item \textbf{View}: состоит из пользовательского интерфейса и отвечает за отображение данных. View наблюдает за изменениями в ViewModel и обновляет интерфейс в соответствии с этими изменениями.
    \item \textbf{ViewModel}: посредник между View и Model. ViewModel запрашивает данные у Model и предоставляет их View, а также обрабатывает пользовательские действия и обновляет Model.
\end{enumerate}

Для управления зависимостями и их внедрения в приложении используется библиотека Koin. В модулях Koin определяются зависимости и способы их создания. Например, можно определить зависимости для сетевого клиента, базы данных и ViewModel. Это позволяет централизованно управлять зависимостями и облегчает их модификацию. Koin автоматически предоставляет экземпляры классов, когда они требуются, что упрощает тестирование и модульность. Например, ViewModel могут получать необходимые репозитории через Koin, что устраняет жёсткие зависимости\cite{ref10}

\newpage
