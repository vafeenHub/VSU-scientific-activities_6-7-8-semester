\section{4. Анализ средств реализации}
\addcontentsline{toc}{section}{4. Анализ средств реализации}

Для достижения поставленных целей и решения задач будут использованы следующие методы анализа и исследования:
\begin{enumerate}
\item Анализ существующих приложений для отслеживания расписания и API.
\item Проектирование пользовательского интерфейса с использованием методов UX/UI дизайна.
\item Разработка и тестирование программного кода приложения.
\end{enumerate}

\subsection{4.1. Обзор существующих языков программирования}
\addcontentsline{toc}{subsection}{4.1. Обзор существующих языков программирования}

Выбор языка программирования является фундаментальным решением, определяющим архитектуру, производительность и поддерживаемость всего проекта. В экосистеме Android традиционно доминировала Java, однако с 2017 года Kotlin, представленный JetBrains, получил официальную поддержку Google и стал приоритетным языком для платформы. Сравнительный анализ выявил существенные различия в философии и прагматике разработки на этих языках.

Java, будучи зрелым, объектно-ориентированным языком с огромной экосистемой и проверенной временем JVM, предоставляет стабильность и предсказуемость. Однако для Android-разработки его синтаксис зачастую избыточен. Создание даже простых data-классов требует написания геттеров, сеттеров, методов `equals()`, `hashCode()` и `toString()` вручную или с помощью генераторов IDE, что увеличивает объем кода и потенциальные источники ошибок. Обработка null-значений, частая причина `NullPointerException`, полностью ложится на разработчика, требуя постоянных проверок. Асинхронные операции и работа с потоками, критически важные для отзывчивого UI, реализуются с помощью сложных механизмов вроде `AsyncTask`, `ThreadPoolExecutor` или сторонних библиотек, таких как RxJava, что усложняет код и его отладку.

В противовес этому, Kotlin с самого проектирования задумывался как прагматичный и лаконичный язык, устраняющий boilerplate-код. Data-классы в Kotlin объявляются одной строкой, автоматически получая все стандартные методы. Система null-безопасности, встроенная в систему типов, устраняет целый класс ошибок на этапе компиляции, различая nullable и non-nullable типы. Для асинхронного программирования Kotlin предлагает корутины — легковесные потоки, позволяющие писать асинхронный код в последовательном, императивном стиле, что радикально упрощает его понимание и поддержку. Дополнительные функции, такие как расширения, позволяющие "добавлять" методы к существующим классам, и параметры по умолчанию в функциях, делают код более выразительным и модульным.

С точки зрения производительности оба языка компилируются в байт-код JVM и демонстрируют сопоставимые результаты в чистом выполнении. Однако производительность разработки и надежность итогового кода в Kotlin выше благодаря упомянутым возможностям. Компилятор Kotlin активно выполняет оптимизации и выявляет потенциальные проблемы (например, неиспользуемые переменные) на ранних этапах. Полная интероперабельность с Java позволяет Kotlin-проекту использовать любые существующие Java-библиотеки, обеспечивая плавную миграцию и доступ к огромной экосистеме.

Сообщество и поддержка стремительно смещаются в сторону Kotlin. Официальная документация Android, новые библиотеки Jetpack (такие как Compose) в первую очередь ориентированы на Kotlin. Инструменты разработки, включая Android Studio, имеют превосходную поддержку Kotlin с продвинутыми рефакторингами и анализом кода. В итоге, несмотря на то, что Java остается надежным выбором для поддержки legacy-проектов, для новой разработки Kotlin предлагает более современный, безопасный, выразительный и эффективный инструмент, напрямую влияющий на скорость разработки и качество кода. Таким образом, выбор был сделан в пользу Kotlin как основного языка реализации проекта.

\subsection{4.2. Обзор существующих фреймворков для интерфейса}
\addcontentsline{toc}{subsection}{4.2. Обзор существующих фреймворков для интерфейса}

Эволюция подходов к созданию пользовательского интерфейса в Android прошла путь от жесткой императивной модели с виджетами на основе `View` и `ViewGroup` до современной декларативной парадигмы. Традиционный подход, использовавшийся более десяти лет, основывается на XML-разметке для описания иерархии элементов и отдельного Java/Kotlin кода для управления их состоянием и поведением (логика в `Activity`/`Fragment`). Этот метод, хотя и знаком миллионам разработчиков, имеет присущие ему недостатки: сильная связанность логики и представления, сложность синхронизации состояния UI с данными, необходимость ручного поиска элементов через `findViewById` (позже — View Binding) и громоздкие механизмы обновления сложных интерфейсов.

Jetpack Compose, анонсированный как современный набор инструментов для верстки пользовательского интерфейса, кардинально меняет эту парадигму. Вместо XML, Compose позволяет описывать интерфейс декларативно с помощью функций на Kotlin, которые называются composable-функциями. Это означает, что разработчик описывает, как должен выглядеть UI при определенном состоянии, а система Compose берет на себя ответственность за его отрисовку и обновление при изменении этого состояния. Такой подход устраняет необходимость в ручном управлении виджетами и их свойствах, снижая вероятность ошибок, таких как утечки памяти из-за неправильной привязки к жизненному циклу.

Ключевое преимущество Compose в производительности — это механизм "интеллектуальной рекомпозиции". Когда изменяется состояние, от которого зависит composable-функция, Compose пересчитывает (рекомпонирует) только те части UI, которые действительно изменились, а не всю иерархию целиком, как это часто бывало в View-системе. Это достигается за счет отслеживания чтения состояния внутри функций. В сочетании с ленивыми компонентами для эффективной работы со списками это приводит к плавной прокрутке и отзывчивости даже на устройствах с ограниченными ресурсами.

Гибкость и выразительность Compose превосходят возможности XML. Создание сложных, кастомных компонентов с анимациями становится значительно проще. Анимации являются первоклассными гражданами в Compose и могут быть добавлены буквально в одну строку кода. Кроме того, Compose тесно интегрирован с Material Design 3, предоставляя готовые, современные и адаптивные компоненты, которые автоматически следуют рекомендациям по дизайну (цветовая схема, типографика, формы). При этом система остается открытой для создания полностью кастомного дизайна.

Хотя сообщество и количество обучающих материалов для традиционного подхода по-прежнему огромны, Compose быстро набирает популярность. Google позиционирует его как будущее UI-разработки под Android, активно развивая и добавляя новые возможности. Важно отметить, что Compose может сосуществовать с существующими View-компонентами в одном проекте (через `AndroidView`), что позволяет постепенно мигрировать крупные приложения.

Для тестирования UI Compose предоставляет специальный набор инструментов (`compose-ui-test`), который позволяет писать семантические тесты, взаимодействуя с интерфейсом на высоком уровне (например, "найти элемент с текстом 'Сохранить' и нажать на него"), что делает тесты более стабильными и читаемыми по сравнению с инструментами вроде Espresso для View-системы. Учитывая все вышеперечисленное — декларативность, производительность, современный дизайн, растущую экосистему и упрощенное тестирование — для реализации пользовательского интерфейса данного проекта был выбран Jetpack Compose.

\subsection{4.3. Обзор существующих фреймворков базы данных}
\addcontentsline{toc}{subsection}{4.3. Обзор существующих фреймворков базы данных}

Локальное хранение структурированных данных является критически важным компонентом для любого офлайн-функционального или эффективно кэширующего данные приложения. Нативным решением для Android на протяжении всей истории платформы является SQLite — легковесная, встраиваемая реляционная СУБД. Работа с "голым" SQLite через `SQLiteOpenHelper` и `Cursor` предоставляет разработчику максимальный контроль: можно писать любые, даже самые экзотические SQL-запросы и вручную оптимизировать схемы баз данных. Однако этот подход сопряжен с серьезными издержками. Разработчик вынужден вручную писать большое количество шаблонного кода для создания и обновления таблиц, преобразования объектов приложения в `ContentValues` и обратно, а также для безопасного выполнения транзакций. Любая ошибка в SQL-запросе (опечатка в имени столбца, неверный тип) обнаруживается только во время выполнения приложения (runtime), что может привести к падению. Процесс миграции схемы базы данных при выходе новых версий приложения также требует крайне аккуратной ручной реализации.

Room Persistence Library, часть Android Jetpack, была создана как абстракция над SQLite, решающая именно эти проблемы. Она реализует популярный паттерн ORM (Object-Relational Mapping), позволяя работать с объектами Kotlin/Java напрямую. Компоненты Room — это аннотированные классы: `@Entity` для определения таблиц, `@Dao` (Data Access Object) для интерфейсов или абстрактных классов, содержащих методы доступа к данным, и `@Database` для описания самой базы. Ключевое преимущество Room — проверка SQL-запросов на этапе компиляции. Компилятор анализирует аннотации `@Query` и сверяет их с объявленными сущностями (`@Entity`). Если запрос ссылается на несуществующее поле или содержит синтаксическую ошибку, компиляция не пройдет, предотвращая множество критических ошибок в рантайме.

С точки зрения чистой скорости выполнения запросов Room и нативный SQLite, как правило, эквивалентны, поскольку Room является тонкой оберткой и в конечном счете генерирует оптимизированный SQL-код. Однако производительность разработки и надежности при использовании Room значительно выше. Библиотека автоматически генерирует код для `@Dao` и работы с `@Database`, избавляя от рутинного кодирования. Встроенная поддержка LiveData и Flow в методах `@Dao` позволяет легко создавать реактивные потоки данных: при изменении информации в таблице все активные наблюдатели (например, UI-компоненты) автоматически получают обновленные данные, что идеально сочетается с архитектурой, основанной на наблюдении за состоянием.

Гибкость Room, хотя и несколько ограниченная по сравнению с прямым SQL, достаточна для подавляющего большинства сценариев. Она поддерживает сложные запросы с джойнами, вложенными объектами (через `@Relation` и `@Embedded`), кастомные преобразователи типов (`@TypeConverter`). Миграция схемы осуществляется через предоставление явных объектов `Migration`, что делает процесс контролируемым и тестируемым. Для тестирования Room предлагает режим базы данных в памяти (`Room.inMemoryDatabaseBuilder`), что позволяет писать быстрые и изолированные unit-тесты без необходимости работы с файловой системой.

Комьюнити и поддержка Room исключительно сильны, так как это официальная рекомендация Google для работы с локальной базой данных. Библиотека активно развивается, интегрируется с другими компонентами Jetpack (например, Paging 3) и имеет обширную документацию. Учитывая преимущества в безопасности типов, скорости разработки, встроенной реактивности и удобстве тестирования, Room был выбран в качестве основного инструмента для реализации слоя локального хранения данных в проекте. \cite{ref3}

\subsection{4.4. Обзор существующих фреймворков для работы с сетью}
\addcontentsline{toc}{subsection}{4.4. Обзор существующих фреймворков для работы с сетью}

Сетевой слой — это мост между клиентским приложением и серверной логикой, и его надежность, эффективность и простота использования напрямую влияют на пользовательский опыт. При анализе инструментов для Android фокус сместился с рассмотрения низкоуровневых `HttpURLConnection` на библиотеки более высокого уровня. Ведущими кандидатами в этой области являются OkHttp и Retrofit, причем важно понимать их концепцию: Retrofit не заменяет OkHttp, а строится поверх него, добавляя уровень абстракции.

OkHttp, разработанный компанией Square, — это мощный HTTP-клиент, реализующий современные стандарты сети. Он берет на себя множество сложных задач: управление пулом соединений (connection pooling) для уменьшения задержки при повторных запросах, прозрачное сжатие GZIP для экономии трафика, кэширование ответов в соответствии с HTTP-спецификацией для работы в офлайн-режиме или ускорения повторных запросов, а также поддержку HTTP/2 и WebSockets. OkHttp предоставляет гибкий механизм интерцепторов (Interceptors), который позволяет встраиваться в цепочку обработки запроса и ответа. Это используется для добавления общих заголовков (например, авторизации), логирования, обработки ошибок или даже модификации запросов на лету. Однако использование "чистого" OkHttp для типичных REST API все еще требует написания значительного объема кода для сериализации объектов приложения в JSON (и обратно) и организации асинхронных вызовов. \cite{ref5}

Retrofit, также продукт Square, решает эти проблемы, предоставляя декларативный подход к определению сетевых операций. Разработчик описывает API в виде интерфейса на Kotlin, аннотируя методы и их параметры (`@GET`, `@POST`, `@Path`, `@Query`, `@Body` и др.). Retrofit во время выполнения генерирует реализацию этого интерфейса, которая преобразует вызовы метода в HTTP-запросы. Он интегрируется с популярными конвертерами (Gson, Moshi, Jackson) для автоматической сериализации и десериализации данных, что превращает трудоемкий процесс работы с `JSONObject` или `JsonReader` в простую работу с типами данных Kotlin (data-классами). Асинхронность легко достигается за счет возвращаемого типа метода: изначально это был `Call<T>`, теперь же стандартом стала поддержка Kotlin coroutines через `suspend`-функции, что делает сетевой код линейным и легко читаемым.

Таким образом, связка Retrofit + OkHttp является оптимальной. Retrofit выступает как фасад для удобного описания API, а OkHttp остается своеобразным "двигателем", отвечающим за транспортные операции, безопасность и низкоуровневые оптимизации. Разработчик может сконфигурировать кастомный экземпляр `OkHttpClient` с нужными таймаутами, интерцепторами (например, для добавления логов или индикатора загрузки) и кэшем, а затем передать его в билдер Retrofit.

Гибкость этой связки крайне высока. Через кастомные `CallAdapter.Factory` можно адаптировать Retrofit для работы с любыми другими механизмами (например, RxJava `Observable`, хотя сейчас это менее актуально). `Converter.Factory` позволяет работать с нестандартными форматами данных (не JSON). Обработка ошибок унифицирована: можно использовать интерцепторы OkHttp для обработки кодов ответа на уровне всего приложения или обрабатывать исключения (например, `HttpException` или сетевые ошибки) непосредственно в слое репозитория при работе с корутинами.

Тестирование сетевого слоя, построенного на Retrofit, также упрощено. Для модульных тестов можно легко создать mock-реализацию интерфейса API, возвращающую заданные данные. Для интеграционных тестов можно поднять локальный mock-сервер (например, с помощью MockWebServer из состава OkHttp) и проверить, что приложение корректно формирует запросы и обрабатывает ответы.

Учитывая зрелость, производительность, выразительность API, превосходную поддержку современных подходов (корутины) и простоту тестирования, для реализации сетевых взаимодействий в проекте была выбрана связка Retrofit в качестве декларативного HTTP-клиента и OkHttp в качестве низкоуровневого сетевого стека. Этот выбор является отраслевым стандартом для Android-разработки и обеспечивает надежную основу для коммуникации с backend-сервисами.