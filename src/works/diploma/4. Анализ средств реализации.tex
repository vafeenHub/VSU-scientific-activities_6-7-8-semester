\section*{4. Анализ средств реализации}
\addcontentsline{toc}{section}{4. Анализ средств реализации} % Добавляем в оглавление

Для достижения поставленных целей и решения задач будут использованы следующие методы анализа и исследования:
\begin{enumerate}
\item Анализ существующих приложений для отслеживания расписания и API.
\item Проектирование пользовательского интерфейса с использованием методов UX/UI дизайна.
\item Разработка и тестирование программного кода приложения.
\end{enumerate}


\subsection*{4.1. Обзор существующих языков программирования}
\addcontentsline{toc}{subsection}{4.1. Обзор существующих языков программирования} % Добавляем в оглавление

При сравнении Java и Kotlin выявлены существенные различия в подходах к разработке. Java, будучи зрелым языком, требует больше ручного управления кодом, включая написание геттеров, сеттеров и других шаблонных конструкций, что увеличивает объем работы и вероятность ошибок. В то же время Kotlin предлагает более высокоуровневый подход с автоматической генерацией boilerplate-кода, например, в data-классах, что делает разработку быстрее и удобнее.
В плане производительности оба языка компилируются в байт-код JVM, однако Kotlin предоставляет встроенные оптимизации, такие как null-безопасность и корутины, которые упрощают асинхронное программирование и снижают риск ошибок. Java, хотя и остается высокопроизводительным, требует ручной оптимизации, особенно при работе с памятью и многопоточностью.
Гибкость Kotlin проявляется в поддержке функционального программирования, включая лямбда-выражения и расширения функций, что позволяет писать более лаконичный и модульный код. Java, несмотря на добавление Stream API и лямбд, все еще уступает в этом отношении, требуя большего количества шаблонного кода.
Поддержка и сообщество Java остаются одними из самых больших, что делает язык надежным выбором для legacy-проектов. Однако Kotlin активно развивается, особенно в Android-разработке, и полностью совместим с Java, что позволяет использовать существующие библиотеки и постепенно переходить на более современный стек.
Тестирование в Kotlin упрощается благодаря лаконичному синтаксису и встроенным возможностям, таким как корутины, тогда как в Java для сложных сценариев часто требуются дополнительные библиотеки. 
В итоге Kotlin был выбран как более современный, безопасный и удобный язык, сочетающий производительность Java с улучшенным синтаксисом и инструментами.


\subsection*{4.2. Обзор существующих фреймворков для интерфейса}
\addcontentsline{toc}{subsection}{4.2. Обзор существующих фреймворков для интерфейса} % Добавляем в оглавление

При сравнении подходов к созданию пользовательского интерфейса явно прослеживаются ключевые различия между традиционной XML-версткой и современным Jetpack Compose. XML-верстка, несмотря на свою зрелость и обширную базу существующих решений, демонстрирует ряд существенных ограничений, таких как жесткое разделение логики и интерфейса, необходимость ручного управления View-элементами и сложности с динамическим обновлением контента. В противоположность этому, Jetpack Compose предлагает единый программный подход на Kotlin, где интерфейс описывается декларативно непосредственно в коде, что значительно упрощает разработку и поддержку.
С точки зрения производительности Compose обладает явными преимуществами благодаря своей системе "рекомпозиции", которая интеллектуально обновляет только измененные элементы интерфейса. В отличие от традиционной View-системы с ее глубокими иерархиями и ручной оптимизацией, Compose обеспечивает более эффективное использование ресурсов устройства, что особенно важно для современных требовательных приложений.
Гибкость Compose проявляется в простоте создания сложных анимированных интерфейсов и кастомизации компонентов. В то время как XML-верстка требует написания значительного объема кода для реализации нестандартных решений, Compose предоставляет встроенные инструменты для анимаций и позволяет легко создавать переиспользуемые компоненты.
Несмотря на то, что XML-верстка имеет более обширное сообщество и документацию из-за своей долгой истории, Jetpack Compose активно развивается при поддержке Google и постепенно становится новым стандартом в Android-разработке. Его возможность сосуществования с традиционными View позволяет осуществлять плавный переход на новые технологии.
В области тестирования Compose также предлагает более удобные решения со встроенными инструментами тестирования, что упрощает процесс проверки UI по сравнению с необходимостью использования дополнительных библиотек в случае XML-верстки.
Для написания интерфейса был выбран Jetpack Compose, так как это современный и мощный инструмент для создания пользовательских интерфейсов в Android. Compose позволяет описывать UI прямо в коде на Kotlin, что делает разработку более интуитивной и эффективной. Благодаря своей декларативной природе, Compose упрощает создание динамических и отзывчивых интерфейсов, а также поддерживает современные функции, такие как анимации и Material Design 3. Этот выбор позволяет создавать красивые и производительные приложения с минимальным количеством шаблонного кода.


\subsection*{4.3. Обзор существующих фреймворков базы данных}
\addcontentsline{toc}{subsection}{4.3. Обзор существующих фреймворков базы данных} % Добавляем в оглавление

При выборе подхода к работе с базами данных в Android-приложениях рассматривались два основных решения: нативный SQLite и библиотека Room. Нативный SQLite, являясь стандартным решением для Android, требует значительных усилий при реализации - разработчику необходимо вручную создавать таблицы, писать SQL-запросы и управлять соединениями, что приводит к большому объему шаблонного кода. В отличие от этого, Room предоставляет удобную абстракцию над SQLite, автоматически генерируя необходимый код на основе аннотаций, что значительно сокращает время разработки и уменьшает вероятность ошибок.
С точки зрения производительности оба подхода демонстрируют сопоставимые результаты, так как Room в конечном итоге использует тот же SQLite. Однако Room предлагает дополнительные оптимизации, такие как кэширование запросов и проверка их корректности на этапе компиляции, что позволяет избежать распространенных ошибок, характерных для ручного написания SQL-запросов. При этом нативный SQLite сохраняет преимущество при работе с особо сложными запросами, где может потребоваться тонкая ручная оптимизация.
Гибкость нативного SQLite проявляется в возможности выполнения произвольных запросов и полном контроле над структурой базы данных, однако это требует от разработчика глубоких знаний SQL и тщательного управления миграциями. Room, хотя и ограничивает некоторые низкоуровневые возможности, предоставляет удобные механизмы для работы с транзакциями и миграциями данных, существенно упрощая эти процессы. Особенно ценным является встроенная в Room поддержка LiveData и Flow, позволяющая легко реализовать реактивное обновление интерфейса при изменениях в базе данных.
Несмотря на то, что нативный SQLite имеет более обширную базу знаний и примеров благодаря своей долгой истории, Room активно развивается как часть Android Jetpack и становится стандартом для новых проектов. Его популярность постоянно растет, а сообщество разработчиков расширяется, что обеспечивает хорошую поддержку и наличие актуальных решений для типовых задач.
Важным преимуществом Room являются встроенные инструменты тестирования, такие как возможность создания временных баз данных в памяти, что существенно упрощает процесс написания и выполнения unit-тестов по сравнению с нативным SQLite, где требуется дополнительная настройка тестового окружения.
Таким образом, Room был выбран в качестве основного инструмента для работы с базами данных благодаря своей простоте использования, безопасности типов, отличной интеграции с другими компонентами Android Jetpack и возможности сосредоточиться на бизнес-логике приложения, а не на низкоуровневых деталях работы с SQLite. \cite{ref3}


\subsection*{4.4. Обзор существующих фреймворков для работы с сетью}
\addcontentsline{toc}{subsection}{4.4. Обзор существующих фреймворков для работы с сетью} % Добавляем в оглавление

При разработке сетевого слоя приложения рассматривались два основных подхода: низкоуровневый OkHttp и высокоуровневый Retrofit. OkHttp предоставляет полный контроль над HTTP-запросами, позволяя тонко настраивать все параметры соединения, однако требует значительного объема ручного кода для реализации типовых сценариев. В отличие от него, Retrofit предлагает декларативный подход через аннотированные интерфейсы, автоматизируя создание клиентов и обработку ответов, что существенно сокращает объем шаблонного кода.
С точки зрения производительности оба решения демонстрируют отличные результаты, поскольку Retrofit использует OkHttp в качестве транспортного уровня. OkHttp обеспечивает продвинутые оптимизации, включая поддержку HTTP/2, кэширование и сжатие данных, в то время как Retrofit добавляет удобную абстракцию поверх этих возможностей без потери эффективности.
Гибкость OkHttp проявляется в возможности создания кастомных интерцепторов и полного контроля над запросами, что критично для сложных интеграций. Retrofit, хотя и ограничивает некоторые низкоуровневые возможности, сохраняет доступ к базовым настройкам OkHttp и предоставляет удобные механизмы для адаптации ответов и обработки ошибок.
Оба решения имеют отличную поддержку и активное сообщество благодаря принадлежности к экосистеме Square. OkHttp, как фундаментальная библиотека, используется в большинстве Android-приложений, тогда как Retrofit стал стандартом де-факто для работы с REST API благодаря своей простоте и элегантности API.
В области тестирования Retrofit предлагает более удобный подход, позволяя легко создавать mock-серверы и тестировать API-контракты, в то время как тестирование чистого OkHttp требует больше усилий по настройке тестового окружения.
Таким образом, Retrofit был выбран в качестве основного инструмента для сетевых запросов благодаря простоте реализации типовых сценариев через аннотированные интерфейсы, автоматической сериализации/десериализации данных, гибкой системе адаптеров и конвертеров, полной совместимости с OkHttp, удобным механизмам обработки ошибок и простому процессу тестирования. При этом сохраняется возможность тонкой настройки через кастомные OkHttp-клиенты и интерцепторы, когда это необходимо для сложных случаев интеграции.