% !TEX TS-program = lualatex

\section*{2. Анализ средств реализации}
\addcontentsline{toc}{section}{2. Анализ средств реализации} % Добавляем в оглавление

Для достижения поставленных целей и решения задач будут использованы следующие методы анализа и исследования:
\begin{enumerate}
\item Анализ существующих приложений для отслеживания расписания и API.
\item Проектирование пользовательского интерфейса с использованием методов UX/UI дизайна.
\item Разработка и тестирование программного кода приложения.
\end{enumerate}


\subsection*{2.1. Обзор существующих приложений}
\addcontentsline{toc}{subsection}{2.1. Обзор существующих приложений}
При анализе приложения "Расписание занятий" был выявлен ряд преимуществ. Одним из достоинств является возможность синхронизации данных с Google Sheets API, что обеспечивает актуальное отображение расписания. Еще одним преимуществом выступает функция добавления и редактирования заметок к каждому занятию, повышающая удобство использования. Простота интеграции с Google Sheets и быстрая загрузка данных также относятся к сильным сторонам данного решения. Однако приложение имеет существенные недостатки, среди которых отсутствие поддержки на новых версиях Android и невозможность отображения занятий по числителю/знаменателю. \cite{ref2}
Приложение "Учебный календарь" демонстрирует другие преимущества. Важным достоинством является не только синхронизация с Google Sheets API, но и возможность персонализации интерфейса через изменение цветовой схемы. Особого внимания заслуживает реализация заметок о занятии с функцией их включения и отключения, что предоставляет пользователям гибкость в настройке отображения информации. Еще одним значимым преимуществом стала поддержка отображения занятий по числителю/знаменателю. Однако приложение страдает от перегруженного интерфейса и медленной загрузки данных, а также не предоставляет возможности самостоятельного выбора числителя/знаменателя.
На основании проведенного анализа было принято решение объединить сильные стороны обоих приложений, дополнив их новыми функциями. Ключевыми особенностями разрабатываемого решения станут: возможность изменения цветовой схемы интерфейса, реализация системы заметок о занятии с функцией их отображения/скрытия, а также введение выбора роли (студент/преподаватель) и группы для студентов. Особое внимание уделено реализации самостоятельного выбора числителя/знаменателя, что обеспечит большую гибкость в работе с расписанием независимо от номера недели.

\subsection*{2.2. Обзор существующих языков программирования}
\addcontentsline{toc}{subsection}{2.2. Обзор существующих языков программирования} % Добавляем в оглавление

При сравнении Java и Kotlin выявлены существенные различия в подходах к разработке. Java, будучи зрелым языком, требует больше ручного управления кодом, включая написание геттеров, сеттеров и других шаблонных конструкций, что увеличивает объем работы и вероятность ошибок. В то же время Kotlin предлагает более высокоуровневый подход с автоматической генерацией boilerplate-кода, например, в data-классах, что делает разработку быстрее и удобнее.
В плане производительности оба языка компилируются в байт-код JVM, однако Kotlin предоставляет встроенные оптимизации, такие как null-безопасность и корутины, которые упрощают асинхронное программирование и снижают риск ошибок. Java, хотя и остается высокопроизводительным, требует ручной оптимизации, особенно при работе с памятью и многопоточностью.
Гибкость Kotlin проявляется в поддержке функционального программирования, включая лямбда-выражения и расширения функций, что позволяет писать более лаконичный и модульный код. Java, несмотря на добавление Stream API и лямбд, все еще уступает в этом отношении, требуя большего количества шаблонного кода.
Поддержка и сообщество Java остаются одними из самых больших, что делает язык надежным выбором для legacy-проектов. Однако Kotlin активно развивается, особенно в Android-разработке, и полностью совместим с Java, что позволяет использовать существующие библиотеки и постепенно переходить на более современный стек.
Тестирование в Kotlin упрощается благодаря лаконичному синтаксису и встроенным возможностям, таким как корутины, тогда как в Java для сложных сценариев часто требуются дополнительные библиотеки. 
В итоге Kotlin был выбран как более современный, безопасный и удобный язык, сочетающий производительность Java с улучшенным синтаксисом и инструментами.

\subsection*{2.3. Обзор существующих API}
\addcontentsline{toc}{subsection}{2.3. Обзор существующих API} % Добавляем в оглавление

Использование Google Sheets API для синхронизации данных имеет ряд существенных ограничений, что делает разработку собственного сервера более предпочтительным решением. Одним из основных недостатков является строгое ограничение на количество запросов в минуту, что может привести к задержкам или блокировке доступа при высокой нагрузке, тогда как собственный сервер позволяет гибко масштабировать ресурсы в зависимости от числа пользователей.
Еще одной проблемой Google Sheets API является сложность расширения функциональности, поскольку он не поддерживает такие возможности, как уведомления или аналитика, в то время как собственный сервер предоставляет полный контроль над логикой приложения и позволяет легко интегрировать дополнительные функции.
Изменение данных через Google Sheets также оказывается неудобным, так как требует ручного редактирования таблиц, что повышает риск ошибок, тогда как собственный сервер может быть оснащен удобной административной панелью для управления расписанием.
Производительность Google Sheets API оставляет желать лучшего при работе с большими объемами данных, вызывая задержки, в отличие от собственного сервера, который можно оптимизировать для быстрой обработки запросов.
Кроме того, Google Sheets API ограничен табличной структурой, что затрудняет работу со сложными данными, в то время как собственный сервер поддерживает различные форматы хранения, включая реляционные базы, обеспечивая большую гибкость.
Таким образом, собственный сервер предлагает значительные преимущества, включая полный контроль над данными, масштабируемость, удобство управления и расширяемость, что делает его оптимальным выбором для обеспечения стабильной и функциональной работы приложения.

\subsection*{2.4. Обзор существующих фреймворков для интерфейса}
\addcontentsline{toc}{subsection}{2.4. Обзор существующих фреймворков для интерфейса} % Добавляем в оглавление

При сравнении подходов к созданию пользовательского интерфейса явно прослеживаются ключевые различия между традиционной XML-версткой и современным Jetpack Compose. XML-верстка, несмотря на свою зрелость и обширную базу существующих решений, демонстрирует ряд существенных ограничений, таких как жесткое разделение логики и интерфейса, необходимость ручного управления View-элементами и сложности с динамическим обновлением контента. В противоположность этому, Jetpack Compose предлагает единый программный подход на Kotlin, где интерфейс описывается декларативно непосредственно в коде, что значительно упрощает разработку и поддержку.
С точки зрения производительности Compose обладает явными преимуществами благодаря своей системе "рекомпозиции", которая интеллектуально обновляет только измененные элементы интерфейса. В отличие от традиционной View-системы с ее глубокими иерархиями и ручной оптимизацией, Compose обеспечивает более эффективное использование ресурсов устройства, что особенно важно для современных требовательных приложений.
Гибкость Compose проявляется в простоте создания сложных анимированных интерфейсов и кастомизации компонентов. В то время как XML-верстка требует написания значительного объема кода для реализации нестандартных решений, Compose предоставляет встроенные инструменты для анимаций и позволяет легко создавать переиспользуемые компоненты.
Несмотря на то, что XML-верстка имеет более обширное сообщество и документацию из-за своей долгой истории, Jetpack Compose активно развивается при поддержке Google и постепенно становится новым стандартом в Android-разработке. Его возможность сосуществования с традиционными View позволяет осуществлять плавный переход на новые технологии.
В области тестирования Compose также предлагает более удобные решения со встроенными инструментами тестирования, что упрощает процесс проверки UI по сравнению с необходимостью использования дополнительных библиотек в случае XML-верстки.
Таким образом, Jetpack Compose был выбран как современный, производительный и гибкий фреймворк, который значительно ускоряет разработку интерфейсов за счет сокращения шаблонного кода и предоставления мощных инструментов для создания отзывчивых и интерактивных пользовательских интерфейсов.

\subsection*{2.5. Обзор существующих фреймворков базы данных}
\addcontentsline{toc}{subsection}{2.5. Обзор существующих фреймворков базы данных} % Добавляем в оглавление

При выборе подхода к работе с базами данных в Android-приложениях рассматривались два основных решения: нативный SQLite и библиотека Room. Нативный SQLite, являясь стандартным решением для Android, требует значительных усилий при реализации - разработчику необходимо вручную создавать таблицы, писать SQL-запросы и управлять соединениями, что приводит к большому объему шаблонного кода. В отличие от этого, Room предоставляет удобную абстракцию над SQLite, автоматически генерируя необходимый код на основе аннотаций, что значительно сокращает время разработки и уменьшает вероятность ошибок.
С точки зрения производительности оба подхода демонстрируют сопоставимые результаты, так как Room в конечном итоге использует тот же SQLite. Однако Room предлагает дополнительные оптимизации, такие как кэширование запросов и проверка их корректности на этапе компиляции, что позволяет избежать распространенных ошибок, характерных для ручного написания SQL-запросов. При этом нативный SQLite сохраняет преимущество при работе с особо сложными запросами, где может потребоваться тонкая ручная оптимизация.
Гибкость нативного SQLite проявляется в возможности выполнения произвольных запросов и полном контроле над структурой базы данных, однако это требует от разработчика глубоких знаний SQL и тщательного управления миграциями. Room, хотя и ограничивает некоторые низкоуровневые возможности, предоставляет удобные механизмы для работы с транзакциями и миграциями данных, существенно упрощая эти процессы. Особенно ценным является встроенная в Room поддержка LiveData и Flow, позволяющая легко реализовать реактивное обновление интерфейса при изменениях в базе данных.
Несмотря на то, что нативный SQLite имеет более обширную базу знаний и примеров благодаря своей долгой истории, Room активно развивается как часть Android Jetpack и становится стандартом для новых проектов. Его популярность постоянно растет, а сообщество разработчиков расширяется, что обеспечивает хорошую поддержку и наличие актуальных решений для типовых задач.
Важным преимуществом Room являются встроенные инструменты тестирования, такие как возможность создания временных баз данных в памяти, что существенно упрощает процесс написания и выполнения unit-тестов по сравнению с нативным SQLite, где требуется дополнительная настройка тестового окружения.
Таким образом, Room был выбран в качестве основного инструмента для работы с базами данных благодаря своей простоте использования, безопасности типов, отличной интеграции с другими компонентами Android Jetpack и возможности сосредоточиться на бизнес-логике приложения, а не на низкоуровневых деталях работы с SQLite. \cite{ref3}

\subsection*{2.6. Обзор существующих фреймворков для работы с сетью}
\addcontentsline{toc}{subsection}{2.6. Обзор существующих фреймворков для работы с сетью} % Добавляем в оглавление

При разработке сетевого слоя приложения рассматривались два основных подхода: низкоуровневый OkHttp и высокоуровневый Retrofit. OkHttp предоставляет полный контроль над HTTP-запросами, позволяя тонко настраивать все параметры соединения, однако требует значительного объема ручного кода для реализации типовых сценариев. В отличие от него, Retrofit предлагает декларативный подход через аннотированные интерфейсы, автоматизируя создание клиентов и обработку ответов, что существенно сокращает объем шаблонного кода.
С точки зрения производительности оба решения демонстрируют отличные результаты, поскольку Retrofit использует OkHttp в качестве транспортного уровня. OkHttp обеспечивает продвинутые оптимизации, включая поддержку HTTP/2, кэширование и сжатие данных, в то время как Retrofit добавляет удобную абстракцию поверх этих возможностей без потери эффективности.
Гибкость OkHttp проявляется в возможности создания кастомных интерцепторов и полного контроля над запросами, что критично для сложных интеграций. Retrofit, хотя и ограничивает некоторые низкоуровневые возможности, сохраняет доступ к базовым настройкам OkHttp и предоставляет удобные механизмы для адаптации ответов и обработки ошибок.
Оба решения имеют отличную поддержку и активное сообщество благодаря принадлежности к экосистеме Square. OkHttp, как фундаментальная библиотека, используется в большинстве Android-приложений, тогда как Retrofit стал стандартом де-факто для работы с REST API благодаря своей простоте и элегантности API.
В области тестирования Retrofit предлагает более удобный подход, позволяя легко создавать mock-серверы и тестировать API-контракты, в то время как тестирование чистого OkHttp требует больше усилий по настройке тестового окружения.
Таким образом, Retrofit был выбран в качестве основного инструмента для сетевых запросов благодаря простоте реализации типовых сценариев через аннотированные интерфейсы, автоматической сериализации/десериализации данных, гибкой системе адаптеров и конвертеров, полной совместимости с OkHttp, удобным механизмам обработки ошибок и простому процессу тестирования. При этом сохраняется возможность тонкой настройки через кастомные OkHttp-клиенты и интерцепторы, когда это необходимо для сложных случаев интеграции.